<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Labelling Vectors</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{Labelling Vectors}
-->

<h1>Labelling Vectors</h1>

<p>Many statistical software programs, such as SAS and SPSS, provide support for labelling variables.  Variable labels provide a mechanism to communicate what a variable represents that is not constrained by the naming conventions of the language.  </p>

<p>R does not include native support for labels. Some packages, most notably the <code>Hmisc</code> package, have provided this support.  However, design choices have been made in <code>Hmisc</code> such that the methods associated with assigning labels are not exported from the package. This makes the use of these functions impractical when extending label support to other packages.</p>

<p>The <code>labelVector</code> package provides basic support for labelling atomic vectors and making this support available to other package developers.</p>

<p>It should be noted that labels have not been widely adopted in R programming. Many R operations do not preserve variable attributes, which can result in the loss of labels when a vector is passed through some functions.  Indeed, this may be appropriate, since performing transformations likely alters the meaning of the label. Thus, it is most appropriate to assign labels to completed variables that are unlikely to undergo further transformations.</p>

<h2>Motivation</h2>

<p>When generating summaries for reports to be delivered to a non-technical audience, the variable names used in analytical code may not be adequately descriptive to the audience to provide the full context and meaning of the results.  Variable labels are a compromise that may be inserted to clarify meaning to the audience without requiring excessively difficult variable names to be used in code.</p>

<p>In the table below, a linear model estimating gas mileage is given with terms taken from the variable labels.</p>

<table><thead>
<tr>
<th align="left">term</th>
<th align="right">estimate</th>
<th align="right">se</th>
<th align="right">t</th>
<th align="right">p</th>
</tr>
</thead><tbody>
<tr>
<td align="left">(Intercept)</td>
<td align="right">9.617781</td>
<td align="right">6.9595930</td>
<td align="right">1.381946</td>
<td align="right">0.1779152</td>
</tr>
<tr>
<td align="left">qsec</td>
<td align="right">1.225886</td>
<td align="right">0.2886696</td>
<td align="right">4.246676</td>
<td align="right">0.0002162</td>
</tr>
<tr>
<td align="left">am</td>
<td align="right">2.935837</td>
<td align="right">1.4109045</td>
<td align="right">2.080819</td>
<td align="right">0.0467155</td>
</tr>
<tr>
<td align="left">wt</td>
<td align="right">-3.916504</td>
<td align="right">0.7112016</td>
<td align="right">-5.506882</td>
<td align="right">0.0000070</td>
</tr>
</tbody></table>

<p>In constrast, the following table replaces these term labels with longer, more human-readable terms that assist in the interpretation of the model.</p>

<table><thead>
<tr>
<th align="left">term</th>
<th align="right">estimate</th>
<th align="right">se</th>
<th align="right">t</th>
<th align="right">p</th>
</tr>
</thead><tbody>
<tr>
<td align="left">(Intercept)</td>
<td align="right">9.617781</td>
<td align="right">6.9595930</td>
<td align="right">1.381946</td>
<td align="right">0.1779152</td>
</tr>
<tr>
<td align="left">Quarter mile time</td>
<td align="right">1.225886</td>
<td align="right">0.2886696</td>
<td align="right">4.246676</td>
<td align="right">0.0002162</td>
</tr>
<tr>
<td align="left">Automatic / Manual</td>
<td align="right">2.935837</td>
<td align="right">1.4109045</td>
<td align="right">2.080819</td>
<td align="right">0.0467155</td>
</tr>
<tr>
<td align="left">Vehicle weight</td>
<td align="right">-3.916504</td>
<td align="right">0.7112016</td>
<td align="right">-5.506882</td>
<td align="right">0.0000070</td>
</tr>
</tbody></table>

<h2>Setting Labels</h2>

<p>Labels are set using the <code>set_label</code> function, which applies a length one character string to the <code>label</code> attribute of the variable.  The <code>print</code> method for <code>labelled</code> vectors mimics the print method from the <code>Hmisc</code> package.</p>

<pre><code class="r">library(labelVector)
x &lt;- 1:10
x &lt;- set_label(x, &quot;some integers&quot;)

x
</code></pre>

<pre><code>## some integers
##  [1]  1  2  3  4  5  6  7  8  9 10
</code></pre>

<p>Labels may be retrieved from a labelled vector using the <code>get_label</code> function.</p>

<pre><code class="r">get_label(x)
</code></pre>

<pre><code>## [1] &quot;some integers&quot;
</code></pre>

<p>When a vector does not have a label attribute, the object given to <code>get_label</code> is deparsed and returned as a string instead.</p>

<pre><code class="r">y &lt;- letters

attr(y, &quot;label&quot;) # y has no label attribute
</code></pre>

<pre><code>## NULL
</code></pre>

<pre><code class="r">get_label(y)
</code></pre>

<pre><code>## [1] &quot;y&quot;
</code></pre>

<p>This behavior comes with a caveat that the string returned will match exactly the content given to <code>get_label</code>.</p>

<pre><code class="r">get_label(mtcars$am)
</code></pre>

<pre><code>## [1] &quot;Automatic / Manual&quot;
</code></pre>

<h2>Working with Data Frames</h2>

<p><code>labelVector</code> provides a method to set labels for vectors contained within a data frame without having to use loops, <code>apply</code>s, or repetitive code.  The <code>data.frame</code> method allows labels to be set with on the pattern of <code>var = &quot;label&quot;</code> within the <code>set_label</code> call. This method is also suitable for use inside of chained operations made popular by the <code>magrittr</code> and <code>dplyr</code> packages.</p>

<pre><code class="r">mtcars2 &lt;- 
  set_label(mtcars,
            am = &quot;Automatic&quot;,
            mpg = &quot;Miles per gallon&quot;,
            cyl = &quot;Cylinders&quot;,
            qsec = &quot;Quarter mile time&quot;)
</code></pre>

<p>There is a similar <code>get_label</code> method for data frames that retrieves the labels of each variable in the data frame.</p>

<pre><code class="r">get_label(mtcars2)
</code></pre>

<pre><code>##  [1] &quot;Miles per gallon&quot;  &quot;Cylinders&quot;         &quot;disp&quot;             
##  [4] &quot;hp&quot;                &quot;drat&quot;              &quot;Vehicle weight&quot;   
##  [7] &quot;Quarter mile time&quot; &quot;vs&quot;                &quot;Automatic&quot;        
## [10] &quot;gear&quot;              &quot;carb&quot;
</code></pre>

<p>Or if you desire only to retrieve the labels for a subset of variables, you may use the call</p>

<pre><code class="r">get_label(mtcars2, vars = c(&quot;am&quot;, &quot;mpg&quot;, &quot;cyl&quot;, &quot;qsec&quot;))
</code></pre>

<pre><code>## [1] &quot;Automatic&quot;         &quot;Miles per gallon&quot;  &quot;Cylinders&quot;        
## [4] &quot;Quarter mile time&quot;
</code></pre>

<h2>Interaction with <code>Hmisc</code></h2>

<p>Whereas <code>labelVector</code> provides a similar functionality as is provided by the <code>Hmisc</code> package, and considering the widespread use of <code>Hmisc</code>, consideration is taken for the possibility that <code>labelVector</code> and <code>Hmisc</code> may need to work in the same environment. This is permissible since <code>set_label</code> and <code>get_label</code> both work on the <code>label</code> attribute of a vector and their names do not conflict with the <code>label</code> generic exported by <code>Hmisc</code>.</p>

<p>Notice below that the variable label created using the <code>Hmisc</code> functions is still retrievable with <code>get_label</code>.</p>

<pre><code class="r">library(Hmisc)

var_with_Hmisc_label &lt;- 1:10
label(var_with_Hmisc_label) &lt;- &quot;This label created with Hmisc&quot;

label(var_with_Hmisc_label)
</code></pre>

<pre><code>## [1] &quot;This label created with Hmisc&quot;
</code></pre>

<pre><code class="r">get_label(var_with_Hmisc_label)
</code></pre>

<pre><code>## [1] &quot;This label created with Hmisc&quot;
</code></pre>

<pre><code class="r">var_with_Hmisc_label
</code></pre>

<pre><code>## This label created with Hmisc 
##  [1]  1  2  3  4  5  6  7  8  9 10
</code></pre>

<p>In a similar vein, variable labels created with <code>set_label</code> may be retrieved using the <code>Hmisc</code> functions.</p>

<pre><code class="r">var_with_labelVector_label &lt;- 1:10
var_with_labelVector_label &lt;- 
  set_label(var_with_labelVector_label, &quot;This label created with labelVector&quot;)

get_label(var_with_labelVector_label)
</code></pre>

<pre><code>## [1] &quot;This label created with labelVector&quot;
</code></pre>

<pre><code class="r">label(var_with_labelVector_label)
</code></pre>

<pre><code>## [1] &quot;This label created with labelVector&quot;
</code></pre>

<h2>Example in Use</h2>

<pre><code class="r">library(labelVector)

mtcars &lt;- 
  set_label(mtcars,
            qsec = &quot;Quarter mile time&quot;,
            am = &quot;Automatic / Manual&quot;,
            wt = &quot;Vehicle weight&quot;)

fit &lt;- lm(mpg ~ qsec + am + wt, 
          data = mtcars)

# Create a summary table
res &lt;- as.data.frame(coef(summary(fit)), 
                     stringsAsFactors = FALSE)
res &lt;- cbind(rownames(res), res)
rownames(res) &lt;- NULL
names(res) &lt;- c(&quot;term&quot;, &quot;estimate&quot;, &quot;se&quot;, &quot;t&quot;, &quot;p&quot;)
res$term &lt;- as.character(res$term)



res$term[-1] &lt;- get_label(mtcars, vars = res$term[-1])
kable(res)
</code></pre>

<table><thead>
<tr>
<th align="left">term</th>
<th align="right">estimate</th>
<th align="right">se</th>
<th align="right">t</th>
<th align="right">p</th>
</tr>
</thead><tbody>
<tr>
<td align="left">(Intercept)</td>
<td align="right">9.617781</td>
<td align="right">6.9595930</td>
<td align="right">1.381946</td>
<td align="right">0.1779152</td>
</tr>
<tr>
<td align="left">Quarter mile time</td>
<td align="right">1.225886</td>
<td align="right">0.2886696</td>
<td align="right">4.246676</td>
<td align="right">0.0002162</td>
</tr>
<tr>
<td align="left">Automatic / Manual</td>
<td align="right">2.935837</td>
<td align="right">1.4109045</td>
<td align="right">2.080819</td>
<td align="right">0.0467155</td>
</tr>
<tr>
<td align="left">Vehicle weight</td>
<td align="right">-3.916504</td>
<td align="right">0.7112016</td>
<td align="right">-5.506882</td>
<td align="right">0.0000070</td>
</tr>
</tbody></table>

</body>

</html>
